Terminaux inutilisés dans la grammaire

   VRAI
   FAUX
   CASE
   FUNC


Grammaire

    0 $accept: parser $end

    1 parser: json
    2       | pseudocode

    3 json: '{' lelems '}'

    4 lelems: elemjson ',' lelems
    5       | elemjson

    6 elemjson: LARGEUR ':' ENTIER
    7         | HAUTEUR ':' ENTIER
    8         | DEBUT ':' debutjson
    9         | CASES ':' tabcases

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' direction '}'

   11 direction: BAS
   12          | HAUT
   13          | DROITE
   14          | GAUCHE

   15 tabcases: '[' cases ']'

   16 cases: scase ',' cases
   17      | scase

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' type '}'

   19 type: CAISSE
   20     | TROU
   21     | BILLE
   22     | BLOC

   23 pseudocode: procedure pseudocode
   24           | procedure

   25 procedure: PROC signature

   26 signature: NOM '(' arguments ')' code FINPROC

   27 arguments: argument
   28          | arguments ',' argument

   29 argument: variable ':' typearg

   30 variable: NOM

   31 typearg: NOM

   32 code: ligne code
   33     | ligne

   34 ligne: affectaction
   35      | appelproc
   36      | conditionnelle
   37      | boucle

   38 affectaction: NOM '=' calcul

   39 calcul: calcul OPERATEUR valeur
   40       | valeur

   41 valeur: NOM
   42       | ENTIER

   43 appelproc: NOM '(' params ')'
   44          | NOM "()"

   45 params: param
   46       | params ',' param

   47 param: NOM
   48      | ENTIER

   49 conditionnelle: "si(" expbool ')' code sinon "finsi"

   50 sinon: "sinon" code
   51      | %empty

   52 boucle: "tantque(" expbool ")" code FINTQ

   53 expbool: valeur comparateur valeur

   54 comparateur: INFEG
   55            | SUPEG
   56            | EGGEGG
   57            | INF
   58            | SUP


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
'(' (40) 26 43
')' (41) 26 43 49
',' (44) 4 10 16 18 28 46
':' (58) 6 7 8 9 10 18 29
'=' (61) 38
'[' (91) 15
']' (93) 15
'{' (123) 3 10 18
'}' (125) 3 10 18
error (256)
ENTIER (258) 6 7 10 18 42 48
NOM (259) 26 30 31 38 41 43 44 47
VRAI (260)
FAUX (261)
OPERATEUR (262) 39
HAUTEUR (263) 7
LARGEUR (264) 6
X (265) 10 18
Y (266) 10 18
TYPEJSON (267) 18
BLOC (268) 22
BILLE (269) 21
CAISSE (270) 19
TROU (271) 20
CASE (272)
CASES (273) 9
DEBUT (274) 8
DIRECTION (275) 10
BAS (276) 11
HAUT (277) 12
DROITE (278) 13
GAUCHE (279) 14
FUNC (280)
FINPROC (281) 26
PROC (282) 25
FINTQ (283) 52
INFEG (284) 54
SUPEG (285) 55
EGGEGG (286) 56
INF (287) 57
SUP (288) 58
"()" (289) 44
"si(" (290) 49
"finsi" (291) 49
"sinon" (292) 50
"tantque(" (293) 52
")" (294) 52


Non-terminaux, suivis des règles où ils apparaissent

$accept (49)
    à gauche: 0
parser (50)
    à gauche: 1 2, à droite: 0
json (51)
    à gauche: 3, à droite: 1
lelems (52)
    à gauche: 4 5, à droite: 3 4
elemjson (53)
    à gauche: 6 7 8 9, à droite: 4 5
debutjson (54)
    à gauche: 10, à droite: 8
direction (55)
    à gauche: 11 12 13 14, à droite: 10
tabcases (56)
    à gauche: 15, à droite: 9
cases (57)
    à gauche: 16 17, à droite: 15 16
scase (58)
    à gauche: 18, à droite: 16 17
type (59)
    à gauche: 19 20 21 22, à droite: 18
pseudocode (60)
    à gauche: 23 24, à droite: 2 23
procedure (61)
    à gauche: 25, à droite: 23 24
signature (62)
    à gauche: 26, à droite: 25
arguments (63)
    à gauche: 27 28, à droite: 26 28
argument (64)
    à gauche: 29, à droite: 27 28
variable (65)
    à gauche: 30, à droite: 29
typearg (66)
    à gauche: 31, à droite: 29
code (67)
    à gauche: 32 33, à droite: 26 32 49 50 52
ligne (68)
    à gauche: 34 35 36 37, à droite: 32 33
affectaction (69)
    à gauche: 38, à droite: 34
calcul (70)
    à gauche: 39 40, à droite: 38 39
valeur (71)
    à gauche: 41 42, à droite: 39 40 53
appelproc (72)
    à gauche: 43 44, à droite: 35
params (73)
    à gauche: 45 46, à droite: 43 46
param (74)
    à gauche: 47 48, à droite: 45 46
conditionnelle (75)
    à gauche: 49, à droite: 36
sinon (76)
    à gauche: 50 51, à droite: 49
boucle (77)
    à gauche: 52, à droite: 37
expbool (78)
    à gauche: 53, à droite: 49 52
comparateur (79)
    à gauche: 54 55 56 57 58, à droite: 53


État 0

    0 $accept: . parser $end

    PROC  décalage et aller à l'état 1
    '{'   décalage et aller à l'état 2

    parser      aller à l'état 3
    json        aller à l'état 4
    pseudocode  aller à l'état 5
    procedure   aller à l'état 6


État 1

   25 procedure: PROC . signature

    NOM  décalage et aller à l'état 7

    signature  aller à l'état 8


État 2

    3 json: '{' . lelems '}'

    HAUTEUR  décalage et aller à l'état 9
    LARGEUR  décalage et aller à l'état 10
    CASES    décalage et aller à l'état 11
    DEBUT    décalage et aller à l'état 12

    lelems    aller à l'état 13
    elemjson  aller à l'état 14


État 3

    0 $accept: parser . $end

    $end  décalage et aller à l'état 15


État 4

    1 parser: json .

    $défaut  réduction par utilisation de la règle 1 (parser)


État 5

    2 parser: pseudocode .

    $défaut  réduction par utilisation de la règle 2 (parser)


État 6

   23 pseudocode: procedure . pseudocode
   24           | procedure .

    PROC  décalage et aller à l'état 1

    $défaut  réduction par utilisation de la règle 24 (pseudocode)

    pseudocode  aller à l'état 16
    procedure   aller à l'état 6


État 7

   26 signature: NOM . '(' arguments ')' code FINPROC

    '('  décalage et aller à l'état 17


État 8

   25 procedure: PROC signature .

    $défaut  réduction par utilisation de la règle 25 (procedure)


État 9

    7 elemjson: HAUTEUR . ':' ENTIER

    ':'  décalage et aller à l'état 18


État 10

    6 elemjson: LARGEUR . ':' ENTIER

    ':'  décalage et aller à l'état 19


État 11

    9 elemjson: CASES . ':' tabcases

    ':'  décalage et aller à l'état 20


État 12

    8 elemjson: DEBUT . ':' debutjson

    ':'  décalage et aller à l'état 21


État 13

    3 json: '{' lelems . '}'

    '}'  décalage et aller à l'état 22


État 14

    4 lelems: elemjson . ',' lelems
    5       | elemjson .

    ','  décalage et aller à l'état 23

    $défaut  réduction par utilisation de la règle 5 (lelems)


État 15

    0 $accept: parser $end .

    $défaut  accepter


État 16

   23 pseudocode: procedure pseudocode .

    $défaut  réduction par utilisation de la règle 23 (pseudocode)


État 17

   26 signature: NOM '(' . arguments ')' code FINPROC

    NOM  décalage et aller à l'état 24

    arguments  aller à l'état 25
    argument   aller à l'état 26
    variable   aller à l'état 27


État 18

    7 elemjson: HAUTEUR ':' . ENTIER

    ENTIER  décalage et aller à l'état 28


État 19

    6 elemjson: LARGEUR ':' . ENTIER

    ENTIER  décalage et aller à l'état 29


État 20

    9 elemjson: CASES ':' . tabcases

    '['  décalage et aller à l'état 30

    tabcases  aller à l'état 31


État 21

    8 elemjson: DEBUT ':' . debutjson

    '{'  décalage et aller à l'état 32

    debutjson  aller à l'état 33


État 22

    3 json: '{' lelems '}' .

    $défaut  réduction par utilisation de la règle 3 (json)


État 23

    4 lelems: elemjson ',' . lelems

    HAUTEUR  décalage et aller à l'état 9
    LARGEUR  décalage et aller à l'état 10
    CASES    décalage et aller à l'état 11
    DEBUT    décalage et aller à l'état 12

    lelems    aller à l'état 34
    elemjson  aller à l'état 14


État 24

   30 variable: NOM .

    $défaut  réduction par utilisation de la règle 30 (variable)


État 25

   26 signature: NOM '(' arguments . ')' code FINPROC
   28 arguments: arguments . ',' argument

    ','  décalage et aller à l'état 35
    ')'  décalage et aller à l'état 36


État 26

   27 arguments: argument .

    $défaut  réduction par utilisation de la règle 27 (arguments)


État 27

   29 argument: variable . ':' typearg

    ':'  décalage et aller à l'état 37


État 28

    7 elemjson: HAUTEUR ':' ENTIER .

    $défaut  réduction par utilisation de la règle 7 (elemjson)


État 29

    6 elemjson: LARGEUR ':' ENTIER .

    $défaut  réduction par utilisation de la règle 6 (elemjson)


État 30

   15 tabcases: '[' . cases ']'

    '{'  décalage et aller à l'état 38

    cases  aller à l'état 39
    scase  aller à l'état 40


État 31

    9 elemjson: CASES ':' tabcases .

    $défaut  réduction par utilisation de la règle 9 (elemjson)


État 32

   10 debutjson: '{' . X ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' direction '}'

    X  décalage et aller à l'état 41


État 33

    8 elemjson: DEBUT ':' debutjson .

    $défaut  réduction par utilisation de la règle 8 (elemjson)


État 34

    4 lelems: elemjson ',' lelems .

    $défaut  réduction par utilisation de la règle 4 (lelems)


État 35

   28 arguments: arguments ',' . argument

    NOM  décalage et aller à l'état 24

    argument  aller à l'état 42
    variable  aller à l'état 27


État 36

   26 signature: NOM '(' arguments ')' . code FINPROC

    NOM         décalage et aller à l'état 43
    "si("       décalage et aller à l'état 44
    "tantque("  décalage et aller à l'état 45

    code            aller à l'état 46
    ligne           aller à l'état 47
    affectaction    aller à l'état 48
    appelproc       aller à l'état 49
    conditionnelle  aller à l'état 50
    boucle          aller à l'état 51


État 37

   29 argument: variable ':' . typearg

    NOM  décalage et aller à l'état 52

    typearg  aller à l'état 53


État 38

   18 scase: '{' . X ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' type '}'

    X  décalage et aller à l'état 54


État 39

   15 tabcases: '[' cases . ']'

    ']'  décalage et aller à l'état 55


État 40

   16 cases: scase . ',' cases
   17      | scase .

    ','  décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 17 (cases)


État 41

   10 debutjson: '{' X . ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' direction '}'

    ':'  décalage et aller à l'état 57


État 42

   28 arguments: arguments ',' argument .

    $défaut  réduction par utilisation de la règle 28 (arguments)


État 43

   38 affectaction: NOM . '=' calcul
   43 appelproc: NOM . '(' params ')'
   44          | NOM . "()"

    '('   décalage et aller à l'état 58
    '='   décalage et aller à l'état 59
    "()"  décalage et aller à l'état 60


État 44

   49 conditionnelle: "si(" . expbool ')' code sinon "finsi"

    ENTIER  décalage et aller à l'état 61
    NOM     décalage et aller à l'état 62

    valeur   aller à l'état 63
    expbool  aller à l'état 64


État 45

   52 boucle: "tantque(" . expbool ")" code FINTQ

    ENTIER  décalage et aller à l'état 61
    NOM     décalage et aller à l'état 62

    valeur   aller à l'état 63
    expbool  aller à l'état 65


État 46

   26 signature: NOM '(' arguments ')' code . FINPROC

    FINPROC  décalage et aller à l'état 66


État 47

   32 code: ligne . code
   33     | ligne .

    NOM         décalage et aller à l'état 43
    "si("       décalage et aller à l'état 44
    "tantque("  décalage et aller à l'état 45

    $défaut  réduction par utilisation de la règle 33 (code)

    code            aller à l'état 67
    ligne           aller à l'état 47
    affectaction    aller à l'état 48
    appelproc       aller à l'état 49
    conditionnelle  aller à l'état 50
    boucle          aller à l'état 51


État 48

   34 ligne: affectaction .

    $défaut  réduction par utilisation de la règle 34 (ligne)


État 49

   35 ligne: appelproc .

    $défaut  réduction par utilisation de la règle 35 (ligne)


État 50

   36 ligne: conditionnelle .

    $défaut  réduction par utilisation de la règle 36 (ligne)


État 51

   37 ligne: boucle .

    $défaut  réduction par utilisation de la règle 37 (ligne)


État 52

   31 typearg: NOM .

    $défaut  réduction par utilisation de la règle 31 (typearg)


État 53

   29 argument: variable ':' typearg .

    $défaut  réduction par utilisation de la règle 29 (argument)


État 54

   18 scase: '{' X . ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' type '}'

    ':'  décalage et aller à l'état 68


État 55

   15 tabcases: '[' cases ']' .

    $défaut  réduction par utilisation de la règle 15 (tabcases)


État 56

   16 cases: scase ',' . cases

    '{'  décalage et aller à l'état 38

    cases  aller à l'état 69
    scase  aller à l'état 40


État 57

   10 debutjson: '{' X ':' . ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' direction '}'

    ENTIER  décalage et aller à l'état 70


État 58

   43 appelproc: NOM '(' . params ')'

    ENTIER  décalage et aller à l'état 71
    NOM     décalage et aller à l'état 72

    params  aller à l'état 73
    param   aller à l'état 74


État 59

   38 affectaction: NOM '=' . calcul

    ENTIER  décalage et aller à l'état 61
    NOM     décalage et aller à l'état 62

    calcul  aller à l'état 75
    valeur  aller à l'état 76


État 60

   44 appelproc: NOM "()" .

    $défaut  réduction par utilisation de la règle 44 (appelproc)


État 61

   42 valeur: ENTIER .

    $défaut  réduction par utilisation de la règle 42 (valeur)


État 62

   41 valeur: NOM .

    $défaut  réduction par utilisation de la règle 41 (valeur)


État 63

   53 expbool: valeur . comparateur valeur

    INFEG   décalage et aller à l'état 77
    SUPEG   décalage et aller à l'état 78
    EGGEGG  décalage et aller à l'état 79
    INF     décalage et aller à l'état 80
    SUP     décalage et aller à l'état 81

    comparateur  aller à l'état 82


État 64

   49 conditionnelle: "si(" expbool . ')' code sinon "finsi"

    ')'  décalage et aller à l'état 83


État 65

   52 boucle: "tantque(" expbool . ")" code FINTQ

    ")"  décalage et aller à l'état 84


État 66

   26 signature: NOM '(' arguments ')' code FINPROC .

    $défaut  réduction par utilisation de la règle 26 (signature)


État 67

   32 code: ligne code .

    $défaut  réduction par utilisation de la règle 32 (code)


État 68

   18 scase: '{' X ':' . ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' type '}'

    ENTIER  décalage et aller à l'état 85


État 69

   16 cases: scase ',' cases .

    $défaut  réduction par utilisation de la règle 16 (cases)


État 70

   10 debutjson: '{' X ':' ENTIER . ',' Y ':' ENTIER ',' DIRECTION ':' direction '}'

    ','  décalage et aller à l'état 86


État 71

   48 param: ENTIER .

    $défaut  réduction par utilisation de la règle 48 (param)


État 72

   47 param: NOM .

    $défaut  réduction par utilisation de la règle 47 (param)


État 73

   43 appelproc: NOM '(' params . ')'
   46 params: params . ',' param

    ','  décalage et aller à l'état 87
    ')'  décalage et aller à l'état 88


État 74

   45 params: param .

    $défaut  réduction par utilisation de la règle 45 (params)


État 75

   38 affectaction: NOM '=' calcul .
   39 calcul: calcul . OPERATEUR valeur

    OPERATEUR  décalage et aller à l'état 89

    $défaut  réduction par utilisation de la règle 38 (affectaction)


État 76

   40 calcul: valeur .

    $défaut  réduction par utilisation de la règle 40 (calcul)


État 77

   54 comparateur: INFEG .

    $défaut  réduction par utilisation de la règle 54 (comparateur)


État 78

   55 comparateur: SUPEG .

    $défaut  réduction par utilisation de la règle 55 (comparateur)


État 79

   56 comparateur: EGGEGG .

    $défaut  réduction par utilisation de la règle 56 (comparateur)


État 80

   57 comparateur: INF .

    $défaut  réduction par utilisation de la règle 57 (comparateur)


État 81

   58 comparateur: SUP .

    $défaut  réduction par utilisation de la règle 58 (comparateur)


État 82

   53 expbool: valeur comparateur . valeur

    ENTIER  décalage et aller à l'état 61
    NOM     décalage et aller à l'état 62

    valeur  aller à l'état 90


État 83

   49 conditionnelle: "si(" expbool ')' . code sinon "finsi"

    NOM         décalage et aller à l'état 43
    "si("       décalage et aller à l'état 44
    "tantque("  décalage et aller à l'état 45

    code            aller à l'état 91
    ligne           aller à l'état 47
    affectaction    aller à l'état 48
    appelproc       aller à l'état 49
    conditionnelle  aller à l'état 50
    boucle          aller à l'état 51


État 84

   52 boucle: "tantque(" expbool ")" . code FINTQ

    NOM         décalage et aller à l'état 43
    "si("       décalage et aller à l'état 44
    "tantque("  décalage et aller à l'état 45

    code            aller à l'état 92
    ligne           aller à l'état 47
    affectaction    aller à l'état 48
    appelproc       aller à l'état 49
    conditionnelle  aller à l'état 50
    boucle          aller à l'état 51


État 85

   18 scase: '{' X ':' ENTIER . ',' Y ':' ENTIER ',' TYPEJSON ':' type '}'

    ','  décalage et aller à l'état 93


État 86

   10 debutjson: '{' X ':' ENTIER ',' . Y ':' ENTIER ',' DIRECTION ':' direction '}'

    Y  décalage et aller à l'état 94


État 87

   46 params: params ',' . param

    ENTIER  décalage et aller à l'état 71
    NOM     décalage et aller à l'état 72

    param  aller à l'état 95


État 88

   43 appelproc: NOM '(' params ')' .

    $défaut  réduction par utilisation de la règle 43 (appelproc)


État 89

   39 calcul: calcul OPERATEUR . valeur

    ENTIER  décalage et aller à l'état 61
    NOM     décalage et aller à l'état 62

    valeur  aller à l'état 96


État 90

   53 expbool: valeur comparateur valeur .

    $défaut  réduction par utilisation de la règle 53 (expbool)


État 91

   49 conditionnelle: "si(" expbool ')' code . sinon "finsi"

    "sinon"  décalage et aller à l'état 97

    $défaut  réduction par utilisation de la règle 51 (sinon)

    sinon  aller à l'état 98


État 92

   52 boucle: "tantque(" expbool ")" code . FINTQ

    FINTQ  décalage et aller à l'état 99


État 93

   18 scase: '{' X ':' ENTIER ',' . Y ':' ENTIER ',' TYPEJSON ':' type '}'

    Y  décalage et aller à l'état 100


État 94

   10 debutjson: '{' X ':' ENTIER ',' Y . ':' ENTIER ',' DIRECTION ':' direction '}'

    ':'  décalage et aller à l'état 101


État 95

   46 params: params ',' param .

    $défaut  réduction par utilisation de la règle 46 (params)


État 96

   39 calcul: calcul OPERATEUR valeur .

    $défaut  réduction par utilisation de la règle 39 (calcul)


État 97

   50 sinon: "sinon" . code

    NOM         décalage et aller à l'état 43
    "si("       décalage et aller à l'état 44
    "tantque("  décalage et aller à l'état 45

    code            aller à l'état 102
    ligne           aller à l'état 47
    affectaction    aller à l'état 48
    appelproc       aller à l'état 49
    conditionnelle  aller à l'état 50
    boucle          aller à l'état 51


État 98

   49 conditionnelle: "si(" expbool ')' code sinon . "finsi"

    "finsi"  décalage et aller à l'état 103


État 99

   52 boucle: "tantque(" expbool ")" code FINTQ .

    $défaut  réduction par utilisation de la règle 52 (boucle)


État 100

   18 scase: '{' X ':' ENTIER ',' Y . ':' ENTIER ',' TYPEJSON ':' type '}'

    ':'  décalage et aller à l'état 104


État 101

   10 debutjson: '{' X ':' ENTIER ',' Y ':' . ENTIER ',' DIRECTION ':' direction '}'

    ENTIER  décalage et aller à l'état 105


État 102

   50 sinon: "sinon" code .

    $défaut  réduction par utilisation de la règle 50 (sinon)


État 103

   49 conditionnelle: "si(" expbool ')' code sinon "finsi" .

    $défaut  réduction par utilisation de la règle 49 (conditionnelle)


État 104

   18 scase: '{' X ':' ENTIER ',' Y ':' . ENTIER ',' TYPEJSON ':' type '}'

    ENTIER  décalage et aller à l'état 106


État 105

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER . ',' DIRECTION ':' direction '}'

    ','  décalage et aller à l'état 107


État 106

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER . ',' TYPEJSON ':' type '}'

    ','  décalage et aller à l'état 108


État 107

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER ',' . DIRECTION ':' direction '}'

    DIRECTION  décalage et aller à l'état 109


État 108

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER ',' . TYPEJSON ':' type '}'

    TYPEJSON  décalage et aller à l'état 110


État 109

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION . ':' direction '}'

    ':'  décalage et aller à l'état 111


État 110

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON . ':' type '}'

    ':'  décalage et aller à l'état 112


État 111

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' . direction '}'

    BAS     décalage et aller à l'état 113
    HAUT    décalage et aller à l'état 114
    DROITE  décalage et aller à l'état 115
    GAUCHE  décalage et aller à l'état 116

    direction  aller à l'état 117


État 112

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' . type '}'

    BLOC    décalage et aller à l'état 118
    BILLE   décalage et aller à l'état 119
    CAISSE  décalage et aller à l'état 120
    TROU    décalage et aller à l'état 121

    type  aller à l'état 122


État 113

   11 direction: BAS .

    $défaut  réduction par utilisation de la règle 11 (direction)


État 114

   12 direction: HAUT .

    $défaut  réduction par utilisation de la règle 12 (direction)


État 115

   13 direction: DROITE .

    $défaut  réduction par utilisation de la règle 13 (direction)


État 116

   14 direction: GAUCHE .

    $défaut  réduction par utilisation de la règle 14 (direction)


État 117

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' direction . '}'

    '}'  décalage et aller à l'état 123


État 118

   22 type: BLOC .

    $défaut  réduction par utilisation de la règle 22 (type)


État 119

   21 type: BILLE .

    $défaut  réduction par utilisation de la règle 21 (type)


État 120

   19 type: CAISSE .

    $défaut  réduction par utilisation de la règle 19 (type)


État 121

   20 type: TROU .

    $défaut  réduction par utilisation de la règle 20 (type)


État 122

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' type . '}'

    '}'  décalage et aller à l'état 124


État 123

   10 debutjson: '{' X ':' ENTIER ',' Y ':' ENTIER ',' DIRECTION ':' direction '}' .

    $défaut  réduction par utilisation de la règle 10 (debutjson)


État 124

   18 scase: '{' X ':' ENTIER ',' Y ':' ENTIER ',' TYPEJSON ':' type '}' .

    $défaut  réduction par utilisation de la règle 18 (scase)
